<!DOCTYPE html>


  <html class="light page-post">


<head>
  <meta charset="utf-8">
  
  <title>LLLHHH的小窝</title>

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
    <meta name="keywords" content="iOS,OC,Swift" />
  

  <meta name="description" content="[TOC]
Swift中的协议

定义： 协议定义了一个蓝图，规定了用来实现某一特定的任务或者功能的方法、属性，或其他需要的东西。
类、结构体、枚举都可以遵循协议，并为协议定义的这鞋要求提供具体实现。某个类型能满足某个协议的要求，就可以说该类型遵循这个协议。
除了遵循协议的类型必须实现的要求外，还可以对协议进行扩展，通过扩展来实现一部分要求或者实现一些附加功能，这样遵循协议的类型就能够使用这些功能">
<meta property="og:type" content="article">
<meta property="og:title" content="LLLHHH的小窝">
<meta property="og:url" content="http://yoursite.com/2017/05/24/Swift中的协议/index.html">
<meta property="og:site_name" content="LLLHHH的小窝">
<meta property="og:description" content="[TOC]
Swift中的协议

定义： 协议定义了一个蓝图，规定了用来实现某一特定的任务或者功能的方法、属性，或其他需要的东西。
类、结构体、枚举都可以遵循协议，并为协议定义的这鞋要求提供具体实现。某个类型能满足某个协议的要求，就可以说该类型遵循这个协议。
除了遵循协议的类型必须实现的要求外，还可以对协议进行扩展，通过扩展来实现一部分要求或者实现一些附加功能，这样遵循协议的类型就能够使用这些功能">
<meta property="og:updated_time" content="2017-05-25T08:02:38.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="LLLHHH的小窝">
<meta name="twitter:description" content="[TOC]
Swift中的协议

定义： 协议定义了一个蓝图，规定了用来实现某一特定的任务或者功能的方法、属性，或其他需要的东西。
类、结构体、枚举都可以遵循协议，并为协议定义的这鞋要求提供具体实现。某个类型能满足某个协议的要求，就可以说该类型遵循这个协议。
除了遵循协议的类型必须实现的要求外，还可以对协议进行扩展，通过扩展来实现一部分要求或者实现一些附加功能，这样遵循协议的类型就能够使用这些功能">

  

  
    <link rel="icon" href="/favicon.ico">
  

  <link href="/css/styles.css?v=028c63b1" rel="stylesheet">


  
    <link rel="stylesheet" href="/css/personal-style.css">
  

  

  
  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?8e32c00c85175d09521ebbfe471a9a58";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>


</head>

<body>


  
    <span id="toolbox-mobile" class="toolbox-mobile">菜单</span>
  

  <div class="post-header CENTER">
   
  <div class="toolbox">
    <a class="toolbox-entry" href="/">
      <span class="toolbox-entry-text">菜单</span>
      <i class="icon-angle-down"></i>
      <i class="icon-home"></i>
    </a>
    <ul class="list-toolbox">
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/archives/"
            rel="noopener noreferrer"
            target="_self"
            >
            博客轴
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/category/"
            rel="noopener noreferrer"
            target="_self"
            >
            分类
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/tag/"
            rel="noopener noreferrer"
            target="_self"
            >
            标签
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/link/"
            rel="noopener noreferrer"
            target="_self"
            >
            友链
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/about/"
            rel="noopener noreferrer"
            target="_self"
            >
            关于
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/atom.xml"
            rel="noopener noreferrer"
            target="_blank"
            >
            RSS
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/search/"
            rel="noopener noreferrer"
            target="_self"
            >
            搜索
          </a>
        </li>
      
    </ul>
  </div>


</div>


  <div id="toc" class="toc-article">
    <strong class="toc-title">文章目录</strong>
    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Swift中的协议"><span class="toc-text">Swift中的协议</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#协议语法"><span class="toc-text">协议语法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#属性协议"><span class="toc-text">属性协议</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#方法协议"><span class="toc-text">方法协议</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Mutating协议要求"><span class="toc-text">Mutating协议要求</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#构造器协议"><span class="toc-text">构造器协议</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#必要构造器"><span class="toc-text">必要构造器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#可失败构造器"><span class="toc-text">可失败构造器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#协议作为类型"><span class="toc-text">协议作为类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#代理模式"><span class="toc-text">代理模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#通过扩展添加协议一致性"><span class="toc-text">通过扩展添加协议一致性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#通过扩展遵循协议"><span class="toc-text">通过扩展遵循协议</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#协议类型的集合"><span class="toc-text">协议类型的集合</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#协议的继承"><span class="toc-text">协议的继承</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#类类型专属协议"><span class="toc-text">类类型专属协议</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#协议合成"><span class="toc-text">协议合成</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#检查协议一致性"><span class="toc-text">检查协议一致性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#可选的协议要求"><span class="toc-text">可选的协议要求</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#协议扩展"><span class="toc-text">协议扩展</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#提供默认实现"><span class="toc-text">提供默认实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#为协议扩展添加限制条件"><span class="toc-text">为协议扩展添加限制条件</span></a></li></ol></li></ol></li></ol>
  </div>



<div class="content content-post CENTER">
   <article id="post-Swift中的协议" class="article article-type-post" itemprop="blogPost">
  <header class="article-header">
    <h1 class="post-title">(no title)</h1>

    <div class="article-meta">
      <span>
        <i class="icon-calendar"></i>
        <span>2017.05.24</span>
      </span>

      
        <span class="article-author">
          <i class="icon-user"></i>
          <span>LLLHHH</span>
        </span>
      

      


      

    </div>
  </header>

  <div class="article-content">
    
      <p>[TOC]</p>
<h1 id="Swift中的协议"><a href="#Swift中的协议" class="headerlink" title="Swift中的协议"></a>Swift中的协议</h1><blockquote>
<ul>
<li>定义： 协议定义了一个蓝图，规定了用来实现某一特定的任务或者功能的方法、属性，或其他需要的东西。</li>
<li><strong>类、结构体、枚举</strong>都可以遵循协议，并为协议定义的这鞋要求提供具体实现。某个类型能满足某个协议的要求，就可以说该类型遵循这个协议。</li>
<li>除了遵循协议的类型必须实现的要求外，还可以对协议进行<strong>扩展</strong>，通过扩展来实现一部分要求或者实现一些附加功能，这样遵循协议的类型就能够使用这些功能。</li>
</ul>
</blockquote>
<h2 id="协议语法"><a href="#协议语法" class="headerlink" title="协议语法"></a>协议语法</h2><ul>
<li><p>协议定义方式和类、结构体和枚举的定义方式类似：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">protocol SomeProtocol &#123;</div><div class="line">  <span class="comment">// 这里是协议的定义部分</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>自定义类型遵循某个协议时，要在类型名称后加上些协议名称，中间用冒号<strong>:</strong>分割。遵循多个协议是，各个协议之间用逗号<strong>,</strong>隔开：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">struct SomeStructure: FirstProtocol, AnotherProtocol &#123;</div><div class="line">    <span class="comment">// 这里是结构体的定义部分</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>当拥有父类在遵循协议时，用该将父类放在<strong>协议名之前</strong>，用逗号<strong>,</strong>隔开：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">class SomeClass: SomeSuperClass, FirstProtocol, AnotherProtocol &#123;</div><div class="line">    // 这里是类的定义部分</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="属性协议"><a href="#属性协议" class="headerlink" title="属性协议"></a>属性协议</h2><blockquote>
<ul>
<li>协议可以要求遵循协议的类型提供<strong>特定</strong>名称和类型的<strong>实例属性或类型属性</strong>。协议不指定属性是存储型属性还是计算型属性，它只指定属性的名称和类型。此外，协议还指定属性是可读的还是可读可写的。</li>
<li>如果协议要求属性是<strong>可读可写</strong>的，那么该属性<strong>不能是常量属性或只读的计算型属性</strong>。如果协议只要求属性是可读的，那么该属性不仅可以是可读的，如果代码需要的话，还可以是可写的。</li>
<li>协议总是用 <strong>var</strong> 关键字来声明变量属性，在类型声明后加上 <strong>{ set get }</strong> 来表示属性是可读可写的，可读属性则用 <strong>{ get }</strong> 来表示：</li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">protocol SomeProtocol &#123;</div><div class="line">    var mustBeSettable: Int &#123; get set &#125;</div><div class="line">    var doesNotNeedToBeSettable: Int &#123; get &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>当协议中定义类型属性时，总是使用<strong>static</strong>关键字作为前缀。当类类型遵循协议时，除了static，还可以用<strong>class</strong>关键字来生命类类型属性：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">protocol AnotherProtocol &#123;</div><div class="line">    static var someTypeProperty: Int &#123; get set &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如下所示，这是一个只含有一个实例属性要求的协议：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">protocol FullNamed&#123;</div><div class="line">  var fullNamed: String&#123; get &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>FullName协议除了要求遵循协议的类型提供fullname属性之外，并无其他要求。<br>下面是一个遵循FullNamed协议的一个结构体：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span>: <span class="title">fullNamed</span></span>&#123;</div><div class="line">  <span class="keyword">var</span> fullNamed: string</div><div class="line">&#125;</div><div class="line"><span class="keyword">let</span> john = <span class="type">Person</span>(fullName: <span class="string">"John Appleseed"</span>)</div></pre></td></tr></table></figure></p>
<p>Person结构体中每一个实例都有一个叫fullnamed的存储型属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">class Starship: FullyNamed &#123;</div><div class="line">    var prefix: String?</div><div class="line">    var name: String</div><div class="line">    init(name: String, prefix: String? = nil) &#123;</div><div class="line">        self.name = name</div><div class="line">        self.prefix = prefix</div><div class="line">    &#125;</div><div class="line">    var fullName: String &#123;</div><div class="line">        return (prefix != nil ? prefix! + &quot; &quot; : &quot;&quot;) + name</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Starship来吧fullname属性实现为只读的计算型属性。</p>
<h2 id="方法协议"><a href="#方法协议" class="headerlink" title="方法协议"></a>方法协议</h2><blockquote>
<ul>
<li>协议可以要求遵循协议的类型实现某些指定的<strong>实例方法</strong>或<strong>类方法</strong>。这些方法作为协议的一部分，像普通方法一样放在协议的定义中，但是<strong>不需要大括号和方法体</strong>。可以在协议中定义具有<strong>可变参数</strong>的方法，和普通方法的定义方式相同。但是，<strong>不支持为协议中的方法的参数提供默认值。</strong></li>
<li>在协议中定义类方法的时候，总是使用<strong>static</strong>关键字作为前缀。当类类型遵循协议时，也可以使用<strong>class</strong>关键字作为前缀。</li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">protocol SomeProtocol &#123;</div><div class="line">    static func someTypeMethod()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下面的协议之定义了一个实例方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">protocol RandomNumberGenerator &#123;</div><div class="line">    func random() -&gt; Double</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>RandomNumberGenerator 协议要求遵循协议的类型必须要实现一个名为random，返回值为Double类型的实例方法。RandomNumberGenerator协议<strong>并不关心具体的方法实现</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">class LinearCongruentialGenerator: RandomNumberGenerator &#123;</div><div class="line">    var lastRandom = 42.0</div><div class="line">    let m = 139968.0</div><div class="line">    let a = 3877.0</div><div class="line">    let c = 29573.0</div><div class="line">    func random() -&gt; Double &#123;</div><div class="line">        lastRandom = ((lastRandom * a + c) % m)</div><div class="line">        return lastRandom / m</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">let generator = LinearCongruentialGenerator()</div><div class="line">print(&quot;Here&apos;s a random number: \(generator.random())&quot;)</div><div class="line">// 打印 “Here&apos;s a random number: 0.37464991998171”</div><div class="line">print(&quot;And another one: \(generator.random())&quot;)</div><div class="line">// 打印 “And another one: 0.729023776863283”</div></pre></td></tr></table></figure>
<h2 id="Mutating协议要求"><a href="#Mutating协议要求" class="headerlink" title="Mutating协议要求"></a>Mutating协议要求</h2><blockquote>
<ul>
<li>作用：在<strong>方法中改变方法所属的实例</strong>。</li>
<li>在值类型（即结构体和枚举）的实例方法中，将 <strong>mutating</strong> 关键字作为方法的前缀，写在 func 关键字之前，表示可以在该方法中修改它所属的实例以及实例的任意属性的值。</li>
<li>如果你在协议中定义了一个实例方法，该方法会改变遵循该协议的类型的实例，那么在定义协议时需要在方法前加 mutating 关键字。这使得结构体和枚举能够遵循此协议并满足此方法要求。</li>
<li>实现协议中的 mutating 方法时，若是类类型，则不用写 mutating 关键字。而对于<strong>结构体和枚举</strong>，则必须写 mutating 关键字。</li>
</ul>
</blockquote>
<p>如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">protocol Togglable &#123;</div><div class="line">    mutating func toggle()</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>定义了一个只有一个toggle的实例方法，这个方法允许修改实例属性的值。<br>当使用枚举或者结构体来实现Togglable协议时，需要实现一个<strong>前缀为mutating</strong>关键字的toggle方法。</p>
<p>下为一个OnOffSwitch的枚举。有开、关两种状态，用枚举成员On和Off表示。toggle方法前缀为mutating满足Togglable协议要求。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">enum</span> <span class="title">OnOffSwitch</span>: <span class="title">Togglable</span> </span>&#123;</div><div class="line">    <span class="keyword">case</span> <span class="type">Off</span>, <span class="type">On</span></div><div class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">toggle</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</div><div class="line">        <span class="keyword">case</span> <span class="type">Off</span>:</div><div class="line">            <span class="keyword">self</span> = <span class="type">On</span></div><div class="line">        <span class="keyword">case</span> <span class="type">On</span>:</div><div class="line">            <span class="keyword">self</span> = <span class="type">Off</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> lightSwitch = <span class="type">OnOffSwitch</span>.<span class="type">Off</span></div><div class="line">lightSwitch.toggle()</div><div class="line"><span class="comment">// lightSwitch 现在的值为 .On</span></div></pre></td></tr></table></figure>
<h2 id="构造器协议"><a href="#构造器协议" class="headerlink" title="构造器协议"></a>构造器协议</h2><blockquote>
<p>协议可以要求遵循协议的类型实现指定的构造器。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">protocol SomeProtocol&#123;</div><div class="line">  init(somePara:Int)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="必要构造器"><a href="#必要构造器" class="headerlink" title="必要构造器"></a>必要构造器</h3><blockquote>
<p>在遵循协议的类中实现构造器，无论是作为指定构造器，还是作为便利构造器。无论哪种情况，你都必须为构造器实现标上 required 修饰符：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">class SomeClass: SomeProtocol &#123;</div><div class="line">    required init(someParameter: Int) &#123;</div><div class="line">        // 这里是构造器的实现部分</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用required修饰符可以确保所有子类也必须提供构造器实现，从而也能符合协议。</p>
<blockquote>
<p>如果类已经被标记为 <strong>final</strong>，那么<strong>不需要</strong>在协议构造器的实现中使用 required 修饰符，因为 <strong>final 类不能有子类</strong>。关于 final 修饰符的更多内容，请参见防止重写。</p>
<p>如果一个子类重写了父类的指定构造器，并且该构造器满足了某个协议的要求，那么该构造器的实现需要同时标注 required 和 override 修饰符：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">protocol SomeProtocol &#123;</div><div class="line">    init()</div><div class="line">&#125;</div><div class="line"> </div><div class="line">class SomeSuperClass &#123;</div><div class="line">    init() &#123;</div><div class="line">        // 这里是构造器的实现部分</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">class SomeSubClass: SomeSuperClass, SomeProtocol &#123;</div><div class="line">    // 因为遵循协议，需要加上 required</div><div class="line">    // 因为继承自父类，需要加上 override</div><div class="line">    required override init() &#123;</div><div class="line">        // 这里是构造器的实现部分</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="可失败构造器"><a href="#可失败构造器" class="headerlink" title="可失败构造器"></a>可失败构造器</h3><blockquote>
<ul>
<li>协议还可以遵循协议的类型定义可失败构造器。</li>
<li>遵循协议的类型可以通过可失败构造器<strong>(init?)</strong>或非可失败构造器<strong>(init)</strong>来满足协议中定义的可失败构造器要求。协议中定义的非可失败构造器要求可以通过非可失败构造器（init）或隐式解包可失败构造器（init）来满足。</li>
</ul>
</blockquote>
<h2 id="协议作为类型"><a href="#协议作为类型" class="headerlink" title="协议作为类型"></a>协议作为类型</h2><blockquote>
<ul>
<li><p>尽管协议本身并未实现任何功能，但是协议可以被当做一个<strong>成熟的类型</strong>来使用。</p>
<p>协议可以像其他普通类型一样使用，使用场景如下：</p>
<ul>
<li>作为函数、方法或构造器中的参数类型或者返回值类型</li>
<li>作为常量、变量或属性的类型</li>
<li>作为数组、字典或其他容器的元素类型</li>
</ul>
</li>
</ul>
<p>协议是一种<strong>类型</strong>，因此协议类型的名称应与其他类型（例如 Int，Double，String）的写法相同，使用<strong>大写字母开头的驼峰式写法</strong>，例如（FullyNamed 和 RandomNumberGenerator）。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">class Dice &#123;</div><div class="line">    let sides: Int</div><div class="line">    let generator: RandomNumberGenerator</div><div class="line">    init(sides: Int, generator: RandomNumberGenerator) &#123;</div><div class="line">        self.sides = sides</div><div class="line">        self.generator = generator</div><div class="line">    &#125;</div><div class="line">    func roll() -&gt; Int &#123;</div><div class="line">        return Int(generator.random() * Double(sides)) + 1</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面定义了一个Dice类，代表桌球中拥有N个面的🎲。Dice创建的实例包含sides和generator两个属性，前者代表有几个面，后者为🎲提供一个随机数生成器，生成随机点数。</p>
<p>generator属性类型为RandomNumberGenerator，因此所有遵循RandomNumberGenerator协议的类型的实例都可以赋值给generator，除此之外没有其他要求。</p>
<p>Dice 类还有一个构造器，用来设置初始状态。构造器有一个名为 generator，类型为 RandomNumberGenerator 的形参。在调用构造方法创建 Dice 的实例时，可以传入任何遵循 RandomNumberGenerator 协议的实例给 generator。</p>
<p>Dice 类提供了一个名为 roll 的实例方法，用来模拟骰子的面值。它先调用 generator 的 random() 方法来生成一个 [0.0,1.0) 区间内的随机数，然后使用这个随机数生成正确的骰子面值。因为 generator 遵循了 RandomNumberGenerator 协议，可以确保它有个 random() 方法可供调用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var d6 = Dice(sides: <span class="number">6</span>, generator: LinearCongruentialGenerator())</div><div class="line"><span class="keyword">for</span> _ in <span class="number">1</span>...<span class="number">5</span> &#123;</div><div class="line">    print(<span class="string">"Random dice roll is \(d6.roll())"</span>)</div><div class="line">&#125;</div><div class="line"><span class="comment">// Random dice roll is 3</span></div><div class="line"><span class="comment">// Random dice roll is 5</span></div><div class="line"><span class="comment">// Random dice roll is 4</span></div><div class="line"><span class="comment">// Random dice roll is 5</span></div><div class="line"><span class="comment">// Random dice roll is 4</span></div></pre></td></tr></table></figure>
<h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><blockquote>
<ul>
<li>代理是一种设计模式，它允许类或结构体将一些需要它们负责的功能委托给其他类型的实例。</li>
<li>定义：定义协议来封装那些需要被委托的功能，这样就能确保遵循协议的类型能提供这些功能。</li>
<li>代理模式可以用来相应特定的动作，或者接受外部数据源提供的数据，为不用关心外部数据源的类型。</li>
</ul>
</blockquote>
<h2 id="通过扩展添加协议一致性"><a href="#通过扩展添加协议一致性" class="headerlink" title="通过扩展添加协议一致性"></a>通过扩展添加协议一致性</h2><p> 在无法修改源代码的情况下，依然可以通过<strong>扩展</strong>令已有类型遵循并符合协议。扩展可以为已有类型添加属性、方法、下标以及构造器，可以符合协议中的要求。</p>
<blockquote>
<p>通过扩展使已有类型遵循并符合协议时，该类型的所有势力也会随之获得协议中定义的各项功能。</p>
</blockquote>
<p> 举个🌰，下面有个TextRepresentable协议，任何想要通过文本表达一些内容的类型都可以实现该协议。<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"> protocol TextRepresentable &#123;</div><div class="line">    var textualDescription: String &#123; get &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p> 可以通过扩展，可以使Dice类遵循协议实现协议方法：<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"> extension Dice: TextRepresentable &#123;</div><div class="line">    var textualDescription: String &#123;</div><div class="line">        return &quot;A \(sides)-sided dice&quot;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p> 通过扩展遵循并符合协议，和在原始定义中遵循并符合协议的效果完全相同。协议名称写在类型名之后，以冒号隔开，然后在扩展的大括号内实现协议要求的内容。</p>
<h2 id="通过扩展遵循协议"><a href="#通过扩展遵循协议" class="headerlink" title="通过扩展遵循协议"></a>通过扩展遵循协议</h2><blockquote>
<p>当一个类已经符合了某个协议中的所有要求，却没有生命遵循该协议时，可以通过空扩展体的扩展来遵循该协议：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">struct Hamster &#123;</div><div class="line">    var name: String</div><div class="line">       var textualDescription: String &#123;</div><div class="line">        return &quot;A hamster named \(name)&quot;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">extension Hamster: TextRepresentable &#123;&#125;</div><div class="line"></div><div class="line">let simonTheHamster = Hamster(name: &quot;Simon&quot;)</div><div class="line">let somethingTextRepresentable: TextRepresentable = simonTheHamster</div><div class="line">print(somethingTextRepresentable.textualDescription)</div><div class="line">// 打印 “A hamster named Simon</div></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>：即使满足了协议的所有要求，类型也不会自动遵循协议，必须显式地遵循协议。</p>
</blockquote>
<h2 id="协议类型的集合"><a href="#协议类型的集合" class="headerlink" title="协议类型的集合"></a>协议类型的集合</h2><blockquote>
<p>协议类型可以在数组或者字典这样的集合中使用。</p>
</blockquote>
<p>下面创建了一个元素类型为<strong>TextRepresentable</strong>的数组：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">let things: [TextRepresentable] = [game, d12, simonTheHamster]</div></pre></td></tr></table></figure></p>
<p>通过遍历things数组，打印每个元素的文本表示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">for thing in things &#123;</div><div class="line">    print(thing.textualDescription)</div><div class="line">&#125;</div><div class="line">// A game of Snakes and Ladders with 25 squares</div><div class="line">// A 12-sided dice</div></pre></td></tr></table></figure></p>
<blockquote>
<p>thing 是 TextRepresentable 类型而不是 Dice，DiceGame，Hamster 等类型，即使实例在幕后确实是这些类型中的一种。由于 thing 是 TextRepresentable 类型，任何 TextRepresentable 的实例都有一个 textualDescription 属性，所以在每次循环中可以安全地访问 thing.textualDescription。</p>
</blockquote>
<h2 id="协议的继承"><a href="#协议的继承" class="headerlink" title="协议的继承"></a>协议的继承</h2><blockquote>
<p>协议能够<strong>继承</strong>一个或者多个其他协议，可以在继承的协议的基础上增加新的要求。协议的继承语法与类的继承相似，多个被继承的协议间用逗号隔开：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">protocol InheritingProtocol: SomeProtocol, AnotherProtocol &#123;</div><div class="line">    // 这里是协议的定义部分</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="类类型专属协议"><a href="#类类型专属协议" class="headerlink" title="类类型专属协议"></a>类类型专属协议</h2><p>通过添加 <strong>class</strong> 关键字来限制协议只能被类类型遵循，而结构体或枚举不能遵循该协议。class 关键字必须第一个出现在协议的继承列表中，在其他继承的协议之前：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">protocol SomeClassOnlyProtocol: class, SomeInheritedProtocol &#123;</div><div class="line">    // 这里是类类型专属协议的定义部分</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>协议 SomeClassOnlyProtocol 只能被<strong>类类型</strong>遵循。如果尝试让结构体或枚举类型遵循该协议，则会导致编译错误。</p>
</blockquote>
<h2 id="协议合成"><a href="#协议合成" class="headerlink" title="协议合成"></a>协议合成</h2><blockquote>
<p>有时需要遵循多个协议，可以将多个协议采用<strong>SomeProtocol &amp; AnotherProtocol</strong> 这样的格式进行组合，成为<strong>协议合成</strong>。<br>可以罗列任意多个你想要遵循的协议，以与符号(&amp;)分隔。<br>举个🌰：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">protocol Named &#123;</div><div class="line">    var name: String &#123; get &#125;</div><div class="line">&#125;</div><div class="line">protocol Aged &#123;</div><div class="line">    var age: Int &#123; get &#125;</div><div class="line">&#125;</div><div class="line">struct Person: Named, Aged &#123;</div><div class="line">    var name: String</div><div class="line">    var age: Int</div><div class="line">&#125;</div><div class="line">func wishHappyBirthday(to celebrator: Named &amp; Aged) &#123;</div><div class="line">    print(&quot;Happy birthday, \(celebrator.name), you&apos;re \(celebrator.age)!&quot;)</div><div class="line">&#125;</div><div class="line">let birthdayPerson = Person(name: &quot;Malcolm&quot;, age: 21)</div><div class="line">wishHappyBirthday(to: birthdayPerson)</div><div class="line">// 打印 “Happy birthday Malcolm - you&apos;re 21!</div></pre></td></tr></table></figure>
<p>这段代码中声明了Named和Aged协议，一个遵循了这两个协议的结构体Person,Person并实现了这两个协议。</p>
<p>wishHappyBirthday(to:) 函数的参数 celebrator 的类型为 Named &amp; Aged。这意味着它<strong>不关心参数的具体类型</strong>，只要参数符合这两个协议即可。</p>
<p>协议合成并不会生成新的、永久的协议类型，而是将多个协议中的要求合成到一个只在局部作用域有</p>
<h2 id="检查协议一致性"><a href="#检查协议一致性" class="headerlink" title="检查协议一致性"></a>检查协议一致性</h2><blockquote>
<p>使用类型转换中描述的 is 和 as 操作符来检查协议一致性，即是否符合某协议，并且可以转换到指定的协议类型。检查和转换到某个协议类型在语法上和类型的检查和转换完全相同：</p>
<ul>
<li>使用类型转换中描述的 is 和 as 操作符来检查协议一致性，即是否符合某协议，并且可以转换到指定的协议类型。检查和转换到某个协议类型在语法上和类型的检查和转换完全相同：</li>
<li>is 用来检查实例是否符合某个协议，若符合则返回 true，否则返回 false。</li>
<li>as? 返回一个可选值，当实例符合某个协议时，返回类型为协议类型的可选值，否则返回 nil。</li>
</ul>
</blockquote>
<p>举个🌰吧：定义一个HasArea的协议，定义了一个只读属性area</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">protocol HasArea&#123;</div><div class="line">  var area: Double&#123;get&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>定义一个Circle和一个Country类，都遵循了HasArea协议：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">class Circle: HasArea &#123;</div><div class="line">    let pi = 3.1415927</div><div class="line">    var radius: Double</div><div class="line">    var area: Double &#123; return pi * radius * radius &#125;</div><div class="line">    init(radius: Double) &#123; self.radius = radius &#125;</div><div class="line">&#125;</div><div class="line">class Country: HasArea &#123;</div><div class="line">    var area: Double</div><div class="line">    init(area: Double) &#123; self.area = area &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最后定义一个Animal类，但是没有遵循HasArea协议：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">class Animal &#123;</div><div class="line">    var legs: Int</div><div class="line">    init(legs: Int) &#123; self.legs = legs</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Circle，Country，Animal 并没有一个共同的基类，尽管如此，它们都是类，它们的实例都可以作为 AnyObject 类型的值，存储在同一个数组中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">let objects: [AnyObject] = [</div><div class="line">    Circle(radius: 2.0),</div><div class="line">    Country(area: 243_610),</div><div class="line">    Animal(legs: 4)</div><div class="line">]</div></pre></td></tr></table></figure>
<p>最后当要对objects数组进行迭代，并对每一个元素进行检查，看它是否符合HasArea协议：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">for object in objects &#123;</div><div class="line">    if let objectWithArea = object as? HasArea &#123;</div><div class="line">        print(&quot;Area is \(objectWithArea.area)&quot;)</div><div class="line">    &#125; else &#123;</div><div class="line">        print(&quot;Something that doesn&apos;t have an area&quot;)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">// Area is 12.5663708</div><div class="line">// Area is 243610.0</div><div class="line">// Something that doesn&apos;t have an area</div></pre></td></tr></table></figure>
<p>当迭代出的元素符合HasArea协议时，将as?操作符返回的可选值通过可选绑定，绑定到objectWithArea常量上。</p>
<blockquote>
<p>objects数组中的元素类型并不会因为强转而丢失类型信息，仍然是Circle,Country,Animal类型。当被赋值给objectWithArea时，只被视为HasArea类型，因此只有area属性能够被访问。</p>
</blockquote>
<h2 id="可选的协议要求"><a href="#可选的协议要求" class="headerlink" title="可选的协议要求"></a>可选的协议要求</h2><blockquote>
<ul>
<li><p>协议可以定义<strong>可选要求</strong>，遵循协议的类型可以选择是否实现这些要求。在协议中使用<strong>optional</strong>关键字作为前缀来定义可选要求。可选要求用在需要和OC打交道的代码中。协议和可选要求都必须带上<strong>@objc</strong>属性。标记@objc特性的协议只能被继承自OC类的类或者@objc类遵循，其他类以及结构体和枚举不能遵循这种协议。</p>
</li>
<li><p>使用可选属性或者方法时，它们的类型会自动编程可选的。比如一个<strong>(Int)-&gt;String</strong>的方法会变成<strong>((Int)-&gt;String)?</strong>。注意：是整个函数类型是<strong>可选</strong>的，而不是函数的返回值。</p>
</li>
</ul>
</blockquote>
<p>下面的例子定义了一个名为 Counter 的用于整数计数的类，它使用外部的数据源来提供每次的增量。数据源由 CounterDataSource 协议定义，包含两个可选要求：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@objc protocol CounterDataSource &#123;</div><div class="line">    optional func incrementForCount(count: Int) -&gt; Int</div><div class="line">    optional var fixedIncrement: Int &#123; get &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>严格来讲，CounterDataSource 协议中的方法和属性都是可选的，因此遵循协议的类可以不实现这些要求，尽管技术上允许这样做，不过最好不要这做。</p>
<p>Counter 类含有 CounterDataSource? 类型的可选属性 dataSource，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">class Counter &#123;</div><div class="line">    var count = 0</div><div class="line">    var dataSource: CounterDataSource?</div><div class="line">    func increment() &#123;</div><div class="line">        if let amount = dataSource?.incrementForCount?(count) &#123;</div><div class="line">            count += amount</div><div class="line">        &#125; else if let amount = dataSource?.fixedIncrement &#123;</div><div class="line">            count += amount</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Counter 类使用变量属性 count 来存储当前值。该类还定义了一个 increment 方法，每次调用该方法的时候，将会增加 count 的值。</p>
<p>increment() 方法首先试图使用 increment(forCount:) 方法来得到每次的增量。increment() 方法使用可选链式调用来尝试调用 increment(forCount:)，并将当前的 count 值作为参数传入。</p>
<p>这里使用了两层可选链式调用。首先，由于 dataSource 可能为 nil，因此在 dataSource 后边加上了 ?，以此表明只在 dataSource 非空时才去调用 increment(forCount:) 方法。其次，即使 dataSource 存在，也无法保证其是否实现了 increment(forCount:) 方法，因为这个方法是可选的。因此，increment(forCount:) 方法同样使用可选链式调用进行调用，只有在该方法被实现的情况下才能调用它，所以在 increment(forCount:) 方法后边也加上了 ?。</p>
<h2 id="协议扩展"><a href="#协议扩展" class="headerlink" title="协议扩展"></a>协议扩展</h2><p>协议可以通过扩展来为遵循协议的类型提供属性。方法以及下标的实现。通过这种方式，基于协议本身来实现这些功能，而无需在每个遵循协议的类型中重复同样的实现，也无需使用全局函数。</p>
<p>例如：通过扩展RandomNumberGenerator协议来提供randomBool()方法。该方法使用协议中定义的random方法来返回一个随机bool值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">extension RandomNumberGenerator &#123;</div><div class="line">    func randomBool() -&gt; Bool &#123;</div><div class="line">        return random() &gt; 0.5</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>通过协议扩展，所有遵循协议的类型，都能自动获取这个扩展所增加的方法实现，无需任何额外修改：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">let generator = LinearCongruentialGenerator()</div><div class="line">print(&quot;Here&apos;s a random number: \(generator.random())&quot;)</div><div class="line">// 打印 “Here&apos;s a random number: 0.37464991998171”</div><div class="line">print(&quot;And here&apos;s a random Boolean:“(generator.randomBool())&quot;)</div><div class="line">// 打印 “And here&apos;s a random Boolean: true</div></pre></td></tr></table></figure></p>
<h3 id="提供默认实现"><a href="#提供默认实现" class="headerlink" title="提供默认实现"></a>提供默认实现</h3><p>可以通过协议扩展来为协议要求的属性。方法以及下标提供默认的实现。如果遵循协议的类型为这些要求提供了自己的实现，那么这些自定义实现将会替代扩展中的默认实现被使用。</p>
<blockquote>
<p>通过协议扩展为协议要求提供的默认实现和可选的协议要求不同。虽然在这两种情况下，遵循协议的类型都无需自己实现这些要求，但是通过扩展提供的默认实现可以直接调用，而无需使用可选链式调用。</p>
</blockquote>
<h3 id="为协议扩展添加限制条件"><a href="#为协议扩展添加限制条件" class="headerlink" title="为协议扩展添加限制条件"></a>为协议扩展添加限制条件</h3><p>在扩展协议的时候，可以指定一些限制条件，只有遵循协议的类型满足这些限制条件时，才能获得协议扩展提供的默认实现。</p>
<blockquote>
<p>这些县纸条简卸载协议名之后，使用where子句来描述。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">extension CollectionType where Generator.Element: TextRepresentable &#123;</div><div class="line">    var textualDescription: String &#123;</div><div class="line">        let itemsAsText = self.map &#123; $0.textualDescription &#125;</div><div class="line">        return &quot;[&quot; +itemsAsText.joinWithSeparator(&quot;, &quot;) + &quot;]&quot;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>textualDescription 属性返回整个集合的文本描述，它将集合中的每个元素的文本描述以逗号分隔的方式连接起来，包在一对方括号中。</p>
<p>textualDescription 属性返回整个集合的文本描述，它将集合中的每个元素的文本描述以逗号分隔的方式连接起来，包在一对方括号中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">let murrayTheHamster = Hamster(name: &quot;Murray&quot;)</div><div class="line">let morganTheHamster = Hamster(name: &quot;Morgan&quot;)</div><div class="line">let mauriceTheHamster = Hamster(name: &quot;Maurice&quot;)</div><div class="line">let hamsters = [murrayTheHamster, morganTheHamster, mauriceTheHamster]</div></pre></td></tr></table></figure>
<p>因为 Array 符合 CollectionType 协议，而数组中的元素又符合 TextRepresentable 协议，所以数组<br>可以使用 textualDescription 属性得到数组内容的文本表示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">可以使用 textualDescription 属性得到数组内容的文本表示：</div></pre></td></tr></table></figure></p>
<blockquote>
<p>注意<br>如果多个协议扩展都为同一个协议要求提供了默认实现，而遵循协议的类型又同时满足这些协议扩展的限制条件，那么将会使用<strong>限制条件最多</strong>的那个协议扩展提供的默认实现。</p>
</blockquote>

    
  </div>
</article>

</div>


  <div class="text-center donation">
    <div class="inner-donation">
      <span class="btn-donation">支持一下</span>
      <div class="donation-body">
        <div class="tip text-center">扫一扫，支持forsigner</div>
        <ul class="theme.donation.items.length">
        
          <li class="item">
            <img src="/images/qr-wechat.png" alt="">
          </li>
        
          <li class="item">
            <img src="/images/qr-alipay.png" alt="">
          </li>
        
        </ul>
      </div>
    </div>
  </div>




  <a id="backTop" class="back-top">
    <i class="icon-angle-up"></i>
  </a>




  <div class="modal" id="modal">
  <span id="cover" class="cover hide"></span>
  <div id="modal-dialog" class="modal-dialog hide-dialog">
    <div class="modal-header">
      <span id="close" class="btn-close">关闭</span>
    </div>
    <hr>
    <div class="modal-body">
      <ul class="list-toolbox">
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/archives/"
              rel="noopener noreferrer"
              target="_self"
              >
              博客轴
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/category/"
              rel="noopener noreferrer"
              target="_self"
              >
              分类
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/tag/"
              rel="noopener noreferrer"
              target="_self"
              >
              标签
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/link/"
              rel="noopener noreferrer"
              target="_self"
              >
              友链
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/about/"
              rel="noopener noreferrer"
              target="_self"
              >
              关于
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/atom.xml"
              rel="noopener noreferrer"
              target="_blank"
              >
              RSS
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/search/"
              rel="noopener noreferrer"
              target="_self"
              >
              搜索
            </a>
          </li>
        
      </ul>

    </div>
  </div>
</div>



  
      <div class="fexo-comments comments-post">
    

    
  <section class="duoshuo-comments">
    <!-- 多说评论框 start -->
    <div class="ds-thread" data-thread-key="http://yoursite.com/2017/05/24/Swift中的协议/index.html" data-title="" data-url="http://yoursite.com/2017/05/24/Swift中的协议/index.html"></div>
    <!-- 多说评论框 end -->
  </section>




  <script type="text/javascript">
  var duoshuoQuery = {short_name:"LLLLHHHH"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0]
     || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
  </script>


  </div>

  

  <script type="text/javascript">
  function loadScript(url, callback) {
    var script = document.createElement('script')
    script.type = 'text/javascript';

    if (script.readyState) { //IE
      script.onreadystatechange = function() {
        if (script.readyState == 'loaded' ||
          script.readyState == 'complete') {
          script.onreadystatechange = null;
          callback();
        }
      };
    } else { //Others
      script.onload = function() {
        callback();
      };
    }

    script.src = url;
    document.getElementsByTagName('head')[0].appendChild(script);
  }

  window.onload = function() {
    loadScript('/js/bundle.js?235683', function() {
      // load success
    });
  }
</script>

</body>
</html>
